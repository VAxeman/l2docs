var __index = {"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Introductory","text":"<p>Welcome to Junior/Full L2 Docs Pages!</p> <p>This page was created with the hopes of helping both new and experienced technicians advance their knowledge and accelerate their salary increases.</p>"},{"location":"TCP-vs-UDP.html","title":"TCP","text":"<p>Transmission Control Protocol is a connection-oriented protocol where a stable connection is established between a client and a server before data can be sent. The data transmitted by TCP protocol is in the form of continuous datastreams.</p> <p>TCP protocol operation is divided into three phases: - Connection establishment - Data transfer - Connection termination</p>"},{"location":"TCP-vs-UDP.html#connection-establishment-three-way-handshake","title":"Connection establishment (Three-way handshake):","text":"<p>Before a client attempts to connect with a server, the server must first bind to and listen at a port to open it up for connections: this is called a passive open. Once the passive open is established, a client may establish a connection by initiating an active open using the three-way (or 3-step) handshake.</p> <p>TCP segment will have a header attached to it which will list out a source and destination port, a segment sequence number and a flag which is used to provide additional information regarding data transfer. In case of a 3-way handshake, we deal with following flgs:</p> <ol> <li>SYN: The active open is performed by the client sending a SYN (synchronize) to the server. The client sets the segment's sequence number to a random value A.</li> <li>SYN-ACK: In response, the server replies with a SYN-ACK (synchronize-acknowledge). The acknowledgment number is set to one more than the received sequence number i.e. A+1, and the sequence number that the server chooses for the packet is another random number, B.</li> <li>ACK: Finally, the client sends an ACK (acknowledge) back to the server. The sequence number is set to the received acknowledgment value i.e. A+1, and the acknowledgment number is set to one more than the received sequence number i.e. B+1.</li> </ol> <p>Steps 1 and 2 establish and acknowledge the sequence number for one direction (client to server). Steps 2 and 3 establish and acknowledge the sequence number for the other direction (server to client). Following the completion of these steps, both the client and server have received acknowledgments and a full-duplex communication is established.</p>"},{"location":"TCP-vs-UDP.html#data-transfer","title":"Data transfer","text":"<p>The Transmission Control Protocol differs in several key features compared to the User Datagram Protocol:</p> <ul> <li>Ordered data transfer: the destination host rearranges segments according to a sequence number</li> <li>Retransmission of lost packets: any cumulative stream not acknowledged is retransmitted</li> <li>Error-free data transfer: corrupted packets are treated as lost and are retransmitted</li> <li>Flow control: limits the rate a sender transfers data to guarantee reliable delivery. The receiver continually hints the sender on how much data can be received. When the receiving host's buffer fills, the next acknowledgment suspends the transfer and allows the data in the buffer to be processed.</li> <li>Congestion control: lost packets (presumed due to congestion) trigger a reduction in data delivery rate</li> </ul>"},{"location":"TCP-vs-UDP.html#connection-termination","title":"Connection termination","text":"<p>The connection termination phase uses a four-way handshake, with each side of the connection terminating independently. When an endpoint wishes to stop its half of the connection, it transmits a FIN packet, which the other end acknowledges with an ACK. Therefore, a typical tear-down requires a pair of FIN and ACK segments from each TCP endpoint. After the side that sent the first FIN has responded with the final ACK, it waits for a timeout before finally closing the connection, during which time the local port is unavailable for new connections; this state lets the TCP client resend the final acknowledgment to the server in case the ACK is lost in transit. </p> <p>The time duration is implementation-dependent, but some common values are 30 seconds, 1 minute, and 2 minutes. After the timeout, the client enters the CLOSED state and the local port becomes available for new connections.</p> <p>It is also possible to terminate the connection by a 3-way handshake, when host A sends a FIN and host B replies with a FIN &amp; ACK (combining two steps into one) and host A replies with an ACK.</p> <p>Source: https://en.wikipedia.org/wiki/Transmission_Control_Protocol</p>"},{"location":"TCP-vs-UDP.html#udp","title":"UDP","text":"<p>UDP is the \u201cfire and forget\u201d type of a protocol. It uses a connectionless communication model with a minimum of protocol mechanisms. </p> <p>UDP datagram header doesn\u2019t possess any of the extra fields TCP segment headers carry to make sure the data is received intact. The trade-off is that a transmission of data is far faster because more data can be packed into a datagram. As such, UDP is utilized in cases where speed is preferable to stability.</p> <p>UDP works best when you have a lot of data that doesn\u2019t need to be perfect or when the systems are so close to each other that the chances of a problem occurring are too small to bother worrying about. A few dropped frames on a Voice over IP call, for example, won\u2019t make much difference in the communication between two people. </p> <p>Two of the most important networking protocols, Domain Name System (DNS) and Dynamic Host Configuration Protocol (DHCP) also use UDP. </p> <p>DHCP uses UDP because DHCP server can\u2019t assume another computer is ready on either side of the session, so each step of a DHCP session just sends the information for that step without any confirmation. </p> <p>Sending a connectionless datagram also makes sense because the client won\u2019t have an IP address to begin the three-way hand-shake. DHCP uses two port numbers: DHCP clients use port 68 for sending data to and receiving data from the DHCP server, and DHCP servers use port 67 for sending and receiving data to and from DHCP clients.</p>"},{"location":"cloudsites.html","title":"Why???!1","text":""},{"location":"dns.html","title":"DNS (Domain Name System)","text":"<p>Humans access information online through domain names, like nytimes.com or espn.com. Web browsers interact through Internet Protocol (IP) addresses. DNS translates domain names to IP addresses so browsers can load Internet resources.</p> <p>The process of DNS resolution involves converting a hostname (such as www.example.com) into a computer-friendly IP address (such as 192.168.1.1). An IP address is given to each device on the Internet, and that address is necessary to find the appropriate Internet device - like a street address is used to find a particular home. When a user wants to load a webpage, a translation must occur between what a user types into their web browser (example.com) and the machine-friendly address necessary to locate the example.com webpage.</p>"},{"location":"dns.html#dns-lookup","title":"DNS lookup","text":"<ol> <li>A DNS lookup typically refers to the process of converting easy to remember names called domain names (like www.google.com) into numbers called IP addresses (like 192.168.2.1). A user types the URL example.com into their web browser.     1.1. Browser cache, device cache, hosts file, router and ISP cache</li> <li>The user\u2019s computer sends a request to the recursive resolver.</li> <li>The recursive resolver then sends a request to the root nameserver which provides the address . of the TLD nameserver responsible for .com domain names.</li> <li>The root nameserver returns the result of the TLD nameserver to the recursive resolver.</li> <li>The recursive resolver sends a request to the .com TLD nameserver which provides the address of the authoritative nameserver responsible for the example.com domain.</li> <li>The TLD nameserver returns the result of the authoritative nameserver to the recursive resolver.</li> <li>The recursive resolver sends a request to the authoritative nameserver responsible for example.com which provides the DNS records requested.</li> <li>The authoritative nameserver returns results to the recursive resolver.</li> <li>The recursive resolver returns DNS records containing the IP address to the browser.</li> <li>The browser makes a request directly to the IP address of the server hosting the website.</li> </ol>"},{"location":"dns.html#host-file","title":"Host file","text":"<p>A hosts file which is used by operating systems to map a connection between an IP address and domain names before going to domain name servers. This file is a simple text file with the mapping of IPs and domain names. Can override DNS and redirect URLs or IP addresses to different locations. </p>"},{"location":"dns.html#dns-servers","title":"DNS servers","text":""},{"location":"dns.html#dns-recursor-recursive-resolver","title":"DNS recursor - recursive resolver","text":"<p>The recursive resolver server is designed to receive browser queries and is in charge of adding new ones.</p> <p>The recursor can be thought of as a librarian who is asked to go find a particular book somewhere in a library. The DNS recursor is a server designed to receive queries from client machines through applications such as web browsers. Typically the recursor is then responsible for making additional requests in order to satisfy the client\u2019s DNS query. A recursive resolver (also known as a DNS recursor) is the first stop in a DNS query. The recursive resolver acts as a middleman between a client and a DNS nameserver. After receiving a DNS query from a web client, a recursive resolver will either respond with cached data, or send a request to a root nameserver, followed by another request to a TLD nameserver, and then one last request to an authoritative nameserver. After receiving a response from the authoritative nameserver containing the requested IP address, the recursive resolver then sends a response to the client. During this process, the recursive resolver will cache information received from authoritative nameservers. When a client requests the IP address of a domain name that was recently requested by another client, the resolver can circumvent the process of communicating with the nameservers, and just deliver the client the requested record from its cache. Most Internet users use a recursive resolver provided by their ISP.</p>"},{"location":"dns.html#root-nameserver","title":"Root nameserver","text":"<p>Used as reference and points to other specific locations.</p> <p>The root server is the first step in translating (resolving) human readable host names into IP addresses. It can be thought of like an index in a library that points to different racks of books - typically it serves as a reference to other more specific locations. The 13 DNS root nameservers are known to every recursive resolver, and they are the first stop in a recursive resolver\u2019s quest for DNS records. A root server accepts a recursive resolver\u2019s query which includes a domain name, and the root nameserver responds by directing the recursive resolver to a TLD nameserver, based on the extension of that domain (.com, .net, .org, etc.). The root nameservers are overseen by a nonprofit called the Internet Corporation for Assigned Names and Numbers (ICANN). Note that while there are 13 root nameserver hostnames, that does not mean that there are only 13 machines in the root nameserver system. There are 13 types of root nameservers, but there are multiple copies of each one all over the world, which use Anycast routing to provide speedy responses. If you added up all the instances of root nameservers, you\u2019d have over 600 different servers.</p>"},{"location":"dns.html#tld-nameserver","title":"TLD nameserver","text":"<p>Contains info on TLD (.com, .net\u2026) </p> <p>The top level domain server (TLD) can be thought of as a specific rack of books in a library. This nameserver is the next step in the search for a specific IP address, and it hosts the last portion of a hostname (In example.com, the TLD server is \u201ccom\u201d). A TLD nameserver maintains information for all the domain names that share a common domain extension, such as .com, .net, or whatever comes after the last dot in a URL. For example, a .com TLD nameserver contains information for every website that ends in \u2018.com\u2019. If a user was searching for google.com, after receiving a response from a root nameserver, the recursive resolver would then send a query to a .com TLD nameserver, which would respond by pointing to the authoritative nameserver (see below) for that domain.</p> <ul> <li>Generic top-level domains: These are domains that are not country specific, some of the best-known generic TLDs include .com, .org, .net, .edu, and .gov.</li> <li>Country code top-level domains: These include any domains that are specific to a country or state. Examples include .uk, .us, .ru, and .jp.</li> </ul>"},{"location":"dns.html#authoritative-nameserver","title":"Authoritative nameserver","text":"<p>Should have info on the requested site (it contains the DNS zone).</p> <p>This final nameserver can be thought of as a dictionary on a rack of books, in which a specific name can be translated into its definition. The authoritative nameserver is the last stop in the nameserver query. If the authoritative name server has access to the requested record, it will return the IP address for the requested hostname back to the DNS Recursor (the librarian) that made the initial request. When a recursive resolver receives a response from a TLD nameserver, that response will direct the resolver to an authoritative nameserver. The authoritative nameserver is usually the resolver\u2019s last step in the journey for an IP address. The authoritative nameserver contains information specific to the domain name it serves (e.g. google.com) and it can provide a recursive resolver with the IP address of that server found in the DNS A record, or if the domain has a CNAME record (alias) it will provide the recursive resolver with an alias domain, at which point the recursive resolver will have to perform a whole new DNS lookup to procure a record from an authoritative nameserver (often an A record containing an IP address). </p> <p>https://www.cloudflare.com/learning/dns/dns-server-types/ </p>"},{"location":"dns.html#dns-records","title":"DNS records","text":""},{"location":"dns.html#a-record","title":"A record","text":"<p>The record that holds the IP address of a domain. The \"A\" stands for \"address\" and this is the most fundamental type of DNS record: it indicates the IP address of a given domain. The most common usage of A records is IP address lookups: matching a domain name (like \"cloudflare.com\") to an IPv4 address. This enables a user's device to connect with and load a website, without the user memorizing and typing in the actual IP address. </p> <ul> <li>DNS AAAA records match a domain name to an IPv6 address. DNS AAAA records are exactly like DNS A records, except that they store a domain's IPv6 address instead of its IPv4 address.</li> </ul>"},{"location":"dns.html#cname-record","title":"CNAME record","text":"<p>Forwards one domain or subdomain to another domain, does NOT provide an IP address.  The \u2018canonical name\u2019 (CNAME) record is used in lieu (in substitution) of an A record, when a domain or subdomain is an alias of another domain. All CNAME records must point to a domain, never to an IP address. </p> <ul> <li>CNAME restrictions - MX and NS records cannot point to a CNAME record; they have to point to an A record (for IPv4) or an AAAA record (for IPv6). </li> </ul>"},{"location":"dns.html#mx-record","title":"MX record","text":"<p>An MX record is a mail exchange record that directs email to a mail server. The MX record indicates how email messages should be routed in accordance with the Simple Mail Transfer Protocol (SMTP, the standard protocol for all email). Like CNAME records, an MX record must always point to another domain.</p>"},{"location":"dns.html#txt-record","title":"TXT record","text":"<p>Lets an admin store text notes in the record. These records are often used for email security. Today, two of the most important uses for DNS TXT records are email spam prevention and domain ownership verification, although TXT records were not designed for these uses originally. One domain can have many TXT records.</p> <p>Together, DMARC, DKIM, and SPF function like a background check on email senders, to make sure they really are who they say they are.</p>"},{"location":"dns.html#spf-record","title":"SPF record","text":"<p>A sender policy framework (SPF) record is a type of DNS TXT record that lists all the servers authorized to send emails from a particular domain. https://www.proofpoint.com/us/threat-reference/spf</p>"},{"location":"dns.html#dkim-record","title":"DKIM record","text":"<p>DomainKeys Identified Mail (DKIM) is a method of email authentication that helps prevent spammers and other malicious parties from impersonating a legitimate domain. https://www.proofpoint.com/us/threat-reference/dkim</p>"},{"location":"dns.html#dmarc","title":"DMARC","text":"<p>Domain-based Message Authentication Reporting and Conformance (DMARC) is a method of authenticating email messages. A DMARC policy tells a receiving email server what to do after checking a domain's Sender Policy Framework (SPF) and DomainKeys Identified Mail (DKIM) records.</p>"},{"location":"dns.html#ns-record","title":"NS record","text":"<p>NS stands for \u2018nameserver,\u2019 and the nameserver record indicates which DNS server is authoritative for that domain (i.e. which server contains the actual DNS records). Basically, NS records tell the Internet where to go to find out a domain's IP address. A domain often has multiple NS records which can indicate primary and secondary nameservers for that domain. Without properly configured NS records, users will be unable to load a website or application.</p>"},{"location":"dns.html#soa-record","title":"SOA record","text":"<p>\u2018Start of authority\u2019 (SOA) record stores important information about a domain or zone such as name of a primary DNS server (hostname of the primary DNS server for the zone, and it should contain a matching NS record), the email address of the administrator, when the domain was last updated, serial number (used by secondary DNS servers to check if the zone has changed), and how long the server should wait between refreshes.</p> <p>Every DNS database file begins with a Start of Authority (SOA) resource record. Whenever you alter any data in a DNS database file, you must increment the SOA serial number by one integer.</p> <p>For example, if the current SOA Serial Number in a data file is 101, and you make a change to the file's data, you must change 101 to 102. If you don't change the SOA serial number, the domain's slave servers do not update their copy of the database files with the new information. The master and slave servers would then be out of sync.</p>"},{"location":"dns.html#srv-record","title":"SRV record","text":"<p>The DNS \"service\" (SRV) record specifies a host and port for specific services such as voice over IP (VoIP), instant messaging, and so on. Most other DNS records only specify a server or an IP address, but SRV records include a port at that IP address as well. Some Internet protocols require the use of SRV records in order to function.</p>"},{"location":"dns.html#ptr-record","title":"PTR record","text":"<p>Provides a domain name in reverse-lookups.  A DNS pointer record (PTR for short) provides the domain name associated with an IP address. A DNS PTR record is exactly the opposite of the 'A' record, which provides the IP address associated with a domain name. DNS PTR records are used in reverse DNS lookups. PTR records store IP addresses with their segments reversed, and they append \".in-addr.arpa\" to that. </p> <p>For example if a domain has an IP address of 192.0.2.1, the PTR record will store the domain's information under 1.2.0.192.in-addr.arpa.</p>"},{"location":"dns.html#glue-record","title":"GLUE record","text":"<p>Glue records are DNS records created at the domain\u2019s registrar. The record provides a complete answer when the TLD nameserver returns a reference for an authoritative nameserver for a domain.  Creating a glue record, an A record served by the TLD nameserver, avoids circular references and allows for both DNS name resolution and listing the nameservers inside the domain itself. Glue records can only be created at the domain registrar as the registrar controls the DNS settings for a given domain\u2019s delegation. Every nameserver on the internet has its own glue record created by the domain\u2019s owner. In normal DNS resolution, when a resolver attempts to resolve a domain name, it first queries the root, which provides the top-level domain. Next, it queries the top-level domain servers, which provide the domain\u2019s authoritative nameservers. Finally, it queries the authoritative nameservers for the domain to resolve the domain name. If the nameservers for a domain exist inside the domain itself, a glue record is needed to resolve the domain name.</p> <p>https://www.cloudflare.com/learning/dns/dns-records/</p>"},{"location":"dns.html#domain-name","title":"Domain name","text":"<p>Simply put, a domain name (or just \u2018domain\u2019) is the name of a website. It\u2019s what comes after \u201c@\u201d in an email address, or after \u201cwww.\u201d in a web address. If someone asks how to find you online, what you tell them is usually your domain name. Domain names are typically broken up into two or three parts, each separated by a dot. To the left of the TLD is the second-level domain (2LD) and if there is anything to the left of the 2LD, it is called the third-level domain (3LD).  For Google\u2019s US domain name, \u2018google.com\u2019:</p> <ul> <li>\u2019.com\u2019 is the TLD (most general)</li> <li>\u2019google\u2019 is the 2LD (most specific)</li> </ul> <p>Difference between a domain name and a URL? A uniform resource locator (URL), sometimes called a web address, contains the domain name of a site as well as other information, including the protocol and the path. For example, in the URL \u2018https://example.com/learning/\u2019, example.com\u2019 is the domain name, while \u2018https\u2019 is the protocol and \u2018/learning/\u2019 is the path to a specific page on the website.</p>"},{"location":"dns.html#fqdn-fully-qualified-domain-name","title":"FQDN - Fully qualified domain name","text":"<p>Check - https://en.wikipedia.org/wiki/Fully_qualified_domain_name</p> <p>A fully qualified domain name (FQDN) is a part of the uniform resource locator (URL). As the name suggests, it is the full name of an entity in the internet framework, including a host and a computer.</p> <p>FQDNs are usually used in any interaction on the internet as they are easier to remember than IP addresses. Below are several scenarios of when to use an FQDN:</p> <ul> <li> <p>Getting an SSL certificate. A secure sockets layer (SSL) protects a connection between a web server and a browser. An SSL certificate is issued to an FQDN, so you may not be able to use SSL services properly without it.</p> </li> <li> <p>Connecting to a remote host. You can make a remote host or a virtual machine by specifying any FQDN, enabling the DNS to look at its DNS table and locate the server. If you use only the hostname to connect to a server, your application may not be able to resolve the hostname.</p> </li> <li> <p>Accessing a specific domain service or protocol. Activities transferring information across a network generally involve the DNS, including pointing to an FQDN. An example is when you connect to a File Transfer Protocol (FTP) or an email server.</p> </li> <li> <p>Migrating to a new server. If you want to migrate your service to a server with a different IP address, using an FQDN instead of an IP address lets you quickly change the DNS record and reduce outages in the IP address changes.</p> </li> </ul>"},{"location":"dns.html#ssl","title":"SSL","text":"<p>SSL, or Secure Sockets Layer, is an encryption-based Internet security protocol. SSL encrypts data that is transmitted across the web. SSL is the predecessor to the modern TLS (Transport Layer Security) encryption used today (but people still refer to it as SSL).</p> <p>Anyone who tries to intercept this data will only see a garbled mix of characters that is nearly impossible to decrypt.</p> <p>SSL initiates an authentication process called a handshake between two communicating devices to ensure that both devices are really who they claim to be. SSL also digitally signs data in order to provide data integrity, verifying that the data is not tampered with before reaching its intended recipient.</p> <ul> <li>Secure Socket Layer</li> <li>SSL encrypts data that is transmitted across the web</li> <li>It initiates an auth process called a handshake between the two communicating devices to make sure that both are what they claim to be</li> <li>It\u2019s now TLS, but still called SSL</li> </ul> <p>https://www.cloudflare.com/learning/ssl/what-is-ssl/</p>"},{"location":"domains.html","title":"Domains","text":""},{"location":"domains.html#domain-name","title":"Domain name","text":"<p>Simply put, a domain name (or just \u2018domain\u2019) is the name of a website. It\u2019s what comes after \u201c@\u201d in an email address, or after \u201cwww.\u201d in a web address. If someone asks how to find you online, what you tell them is usually your domain name. Domain names are typically broken up into two or three parts, each separated by a dot. To the left of the TLD is the second-level domain (2LD) and if there is anything to the left of the 2LD, it is called the third-level domain (3LD).  For Google\u2019s US domain name, \u2018google.com\u2019:</p> <ul> <li>\u2019.com\u2019 is the TLD (most general)</li> <li>\u2019google\u2019 is the 2LD (most specific)</li> </ul> <p>Difference between a domain name and a URL? A uniform resource locator (URL), sometimes called a web address, contains the domain name of a site as well as other information, including the protocol and the path. For example, in the URL \u2018https://example.com/learning/\u2019, example.com\u2019 is the domain name, while \u2018https\u2019 is the protocol and \u2018/learning/\u2019 is the path to a specific page on the website.</p>"},{"location":"domains.html#fqdn-fully-qualified-domain-name","title":"FQDN - Fully qualified domain name","text":"<p>Check - https://en.wikipedia.org/wiki/Fully_qualified_domain_name</p> <p>A fully qualified domain name (FQDN) is a part of the uniform resource locator (URL). As the name suggests, it is the full name of an entity in the internet framework, including a host and a computer.</p> <p>FQDNs are usually used in any interaction on the internet as they are easier to remember than IP addresses. Below are several scenarios of when to use an FQDN:</p> <ul> <li> <p>Getting an SSL certificate. A secure sockets layer (SSL) protects a connection between a web server and a browser. An SSL certificate is issued to an FQDN, so you may not be able to use SSL services properly without it.</p> </li> <li> <p>Connecting to a remote host. You can make a remote host or a virtual machine by specifying any FQDN, enabling the DNS to look at its DNS table and locate the server. If you use only the hostname to connect to a server, your application may not be able to resolve the hostname.</p> </li> <li> <p>Accessing a specific domain service or protocol. Activities transferring information across a network generally involve the DNS, including pointing to an FQDN. An example is when you connect to a File Transfer Protocol (FTP) or an email server.</p> </li> <li> <p>Migrating to a new server. If you want to migrate your service to a server with a different IP address, using an FQDN instead of an IP address lets you quickly change the DNS record and reduce outages in the IP address changes.</p> </li> </ul>"},{"location":"domains.html#ssl","title":"SSL","text":"<p>SSL, or Secure Sockets Layer, is an encryption-based Internet security protocol. SSL encrypts data that is transmitted across the web. SSL is the predecessor to the modern TLS (Transport Layer Security) encryption used today (but people still refer to it as SSL).</p> <p>Anyone who tries to intercept this data will only see a garbled mix of characters that is nearly impossible to decrypt.</p> <p>SSL initiates an authentication process called a handshake between two communicating devices to ensure that both devices are really who they claim to be. SSL also digitally signs data in order to provide data integrity, verifying that the data is not tampered with before reaching its intended recipient.</p> <ul> <li>Secure Socket Layer</li> <li>SSL encrypts data that is transmitted across the web</li> <li>It initiates an auth process called a handshake between the two communicating devices to make sure that both are what they claim to be</li> <li>It\u2019s now TLS, but still called SSL</li> </ul> <p>https://www.cloudflare.com/learning/ssl/what-is-ssl/</p>"},{"location":"internet-models.html","title":"OSI Seven-Layer Model","text":"<p>OSI 7-layer model is a conceptual network format which encourages modular design in networking, meaning that each layer has as little to do with the operation of other layers as possible.</p> <p>Mnemonic: Please Do Not Throw Sausage Pizza Away. </p> <p>The seven layers include:</p> <ul> <li>Layer 7: Application</li> <li>Layer 6: Presentation</li> <li>Layer 5: Session</li> <li>Layer 4: Transport</li> <li>Layer 3: Network\u00a0</li> <li>Layer 2: Data Link</li> <li>Layer 1: Physical</li> </ul>"},{"location":"internet-models.html#layer-7-application-layer","title":"Layer  7. Application layer:","text":"<p>Being the topmost layer of the OSI model, this is the only layer that directly interacts with data from the user. Software applications like web browsers and email clients rely on the application layer to initiate communications. </p> <p>The software applications are not part of the application layer by themselves, but rather the application layer is responsible for the protocols and data manipulation that the software relies on to present meaningful data to the user.</p> <p>Once the user's data has been gathered, application layer will make a connection with the bottom layer - presentation layer for further manipulation. </p> <p>Application layer protocols:  - [[HTTP &amp; HTTPS]] - [[FTP]] - [[4. Emails - Sending, records, software (qmail vs dovecot, their log locations)#Mail Transfer Agent/SMTP|SMTP]] - [[2. DNS (full)#What is DNS?|DNS]]  - [[DHCP]] - [[SSH]]</p>"},{"location":"internet-models.html#layer-6-presentation-layer","title":"Layer 6. Presentation layer:","text":"<p>The presentation layer is responsible for handling the syntax and semantics of the information exchanged between network devices. </p> <p>It handles data conversion, encryption and compression.</p> <ul> <li>Data conversaon </li> <li>Data Encryption </li> <li>Data compression </li> </ul>"},{"location":"internet-models.html#layer-5-session-layer","title":"Layer 5. Session layer","text":"<p>In a network, multiple applications running on different systems may need to communicate with one another. This process is called a session, and the Session layer handles these interactions. It provides the mechanisms for establishing a session between applications, maintaining the session and ending the session once the communication is complete. It also provides mechanisms for synchronization and recovery in case of communication failure or interruptions.\u00a0</p> <p>Lets say we are running an email client, a web browser and a torrent applications at the same time. Each of these applications will be using a different session, which is managed by this layer. This is the reason why we can at the same time have a browser, mail client and torrent client open for example. This layer will assign each of these applications a session so that the data can be managed accordingly. </p>"},{"location":"internet-models.html#layer-4-transport-layer-segmentation-and-reassembly","title":"Layer 4: Transport Layer - Segmentation and Reassembly","text":"<p>Unlike the name would suggest, transport layer does not transport data between different devices. Transport layer's job is to break down data from the upper layers into digestible chunks and to append header with source and destination [[PORTS|port]] so that the machines on a network know which service said data chunks are meant for.</p> <ul> <li>Source port is required on the source machine in cases where we have multiple applications using the same protocol. If, for example, we had multiple browsers installed, when we try to access a website on one through HTTP, we do not want the result to be opened in another browser. Source port will be a random number between 1024-65535.</li> <li>Destination port will depend on which service we require from the destination machine, and will be provided by the application layer. It will most commonly be one of the well known ports (1-1024).</li> </ul> <p>This process is called segmentation, and said chunks are called segments or datagrams.</p> <p>The receiving system then does the reassembly of these segments - recognizes the incoming packets as one data transmission, reassembles the packets correctly based on the information included in the packets by the sending system and verifies that all the packets for that piece of data arrived in good shape.\u00a0</p> <p>The primary functions of the Transport Layer are:</p> <ul> <li> <p>To enable efficient network transmission, the Transport Layer splits the total amount of data it gets from the applications running at the top layers into smaller units known as segments. The Transport Layer puts these bits back together into the original data stream at the other end.</p> </li> <li> <p>In situations when organised data transfer is required, the Transport Layer creates a connection between the source and the destination. In order to create the proper parameters and guarantee that both systems are prepared to communicate data, a handshake protocol is established. When the data transfer is complete, the Transport Layer closes the connection.</p> </li> <li> <p>The transport layer also assures dependable data transmission. Receiving acknowledgments, or ACK bits, is how this is accomplished. While waiting for the recipient to acknowledge the parts it sent, the sender keeps an eye on them. Any damaged segments are retransmitted by the sender if they receive an acknowledgment.</p> </li> <li> <p>Flow regulation - In order to prevent data overload, transport layer regulates the data transfer rate. </p> </li> <li> <p>Both error detection and repair are handled by the transport layer. Checksums are one of these techniques for error detection. By computing and validating checksums, it can ascertain whether data was tampered with during transmission. The Transport Layer will request retransmission if it finds anything.</p> </li> </ul> <p>Depending on whether the connection favors performance or stability, we differentiate two transport layer protocols: - [[TCP vs UDP]]</p>"},{"location":"internet-models.html#layer-3-network-layer","title":"Layer 3: Network Layer","text":"<p>Because these segments will need to travel all over the Internet along different pathways, we need a mechanism that knows once the segment does arrive, which pathway it's supposed to be sent down to so that it all gets to the final destination. This is handled by the Network layer.</p> <p>Network layer will take the segment from the Transport layer, re-encapsulate it by adding a header to it which will have a source and destination IP address. We call this chunk a packet.</p> <p>By far the most common protocol that is used on the Network layer is IPv4 (but it's not the only one).</p> <p>Network Layer handles functions such as: - Assigning Logical Address to devices which are connecting to a network to send/receive data packets.  - Routing - process of identifying the best path to transmit the packets - Host-to-host delivery or Forwarding - process in which the network layer transmits or forwards the data via routers after determining the best path. - Logical subnetting - dividing a bigger network into smaller chunks so that IP addresses are used more efficiently.  - Network Address Translation (NAT) - process of converting any private IP address into a public IP address.</p>"},{"location":"internet-models.html#network-layer-protocols","title":"Network Layer protocols:","text":"<ul> <li>[[Internet Protocol]]</li> <li>[[ICMP]]</li> </ul>"},{"location":"internet-models.html#layer-2-data-link-layer","title":"Layer 2: Data-Link Layer","text":"<p>When we say \"link\", we mean two devices connecting together. Everything up to this layer was a machine readable data. Data-Link layer has a job to take said data and connect it to the last layer - Physical layer. It does this by taking the packet provided by the Network layer and encapsulates it in a frame. </p> <p>Data-Link does splits its job into  two sublayers: - Logical Link Control (LLC) layer talks to the operating system through drivers and handles multiple network protocols and provides flow control. - Media Access Control (MAC) layer creates and addresses the frame. It adds NIC\u2019s MAC address and attaches MAC addresses to the frame, adds and checks the FCS and ensures that frames are sent along the network cabling.\u00a0</p> <p>A frame will consist of a header and a trailer attached to it. Trailer exists because much like all the other layers, Data-Link is also governed by protocols (Ethernet being the most common). </p> <p>Data transmission involves a stream of signals through a physical device, and in nature there are many signals which are just static noise. In order to differentiate data transferred between devices from a static noise, we attach a trailer to the packet. With it, destination device can recognize said stream of data and know how to handle it.</p>"},{"location":"internet-models.html#layer-1-physical-layer","title":"Layer 1: Physical layer","text":"<p>Network needs a physical channel through which the data can be transferred. Most common type is the UTP cable (unshielded twisted pair) which can transmit and receive data, as well as a central box (Hub/Switch) that handles a flow from one machine to another. Each system on a network has a cable connected to the central box.</p> <p>Network Interface Card (NIC) serves as the interface between the PC and the network. Each NIC has a unique identifier with a 48-bit value called media access control address (MAC address) so data is transferred to the right system. No two NICs ever share the same MAC address. Those numbers are provided by Institute of Electrical and Electronics Engineers (IEEE) to the companies making NICs, which often print the numbers onto the device itself using hexadecimal notation.  - Example: 00\u201340\u201305\u201360\u20137D\u201349</p> <p>First six digits in MAC address represent the number of the NIC manufacturer and they are referred to as Organizationally Unique Identifier (OUI) while the last six digits represent the unique serial number for the NIC and are referred to as device ID. Nomenclature for MAC addresses is also known as MAC-48 and EUI-48 (Extended Unique Identifier, chosen for trademarking purposes).\u00a0</p> <p>NICs transfer the information through the UTP cable in the form of binary data that is broken down into discrete chunks called frames. The NICs create and send, as well as receive and read these frames. Different frames are used on different networks and all NICs on the same network must use the same frame type to communicate with other NICs.</p> <p>(Optional)     Frame begins with the MAC address of the NIC to which the data is to be sent, followed by the MAC address of the sending NIC. Next comes the Types\u00a0field which indicates the type of data transferred, followed by the Data field which contains the encapsulated information. Lastly, there is a special bit of checking information called frame check sequence. FCS uses a type of binary math called cyclic redundancy check (CRC) in order to verify that the data has arrived intact. Most wired connections hold up to 1500 bytes of data.\u00a0</p> <p>When a system sends a frame out on the network, the frame goes into the central box. What happens from that point depends on the type of central box. - Hub could make a copy of the frame and send it to all the connected ports except for the port from which the message originated. Only the NIC to which the frame was addressed would process that frame and the others would drop it when they saw it wasn\u2019t addressed to their MAC addresses. - Switch sent a frame only to the interface associated with the destination of the MAC address.</p> <p>(Optional)     In situations where NIC doesn\u2019t know the MAC address of another NIC, they send a broadcast onto the network to ask for it. If a NIC sends a frame using a broadcast address (MAC address FF-FF-FF-FF-FF-FF), that frame is processed by every single NIC on that network. That broadcast frame\u2019s data will contain a request for a system\u2019s MAC address. Without knowing the MAC address to begin with, the requesting computer will use an IP address to pick the target computer out of the crowd. The system that is sought will read the request in the broadcast frame and respond its MAC address.</p> <p>When the frame finally arrives to the destination machine, the entire process will be reversed. - Data Link will remove the header and a trailer from the frame and pass the packet along to the Network layer. - Network layer will remove the header and pass the packet to the Transport layer. - Transport layer will read the destination port and transfer the frame to the appropriate service in the upper layers.</p> <p>PDU - protocol data unit</p>"},{"location":"internet-models.html#tcpip-model","title":"TCP/IP model","text":"<p>The reason why TCP/IP model has this name is because the persons who developed it focused primarily on these two protocols. Back in the day of Arpanet, they needed to be sure that the data was reliable.</p>"},{"location":"internet-models.html#the-application-layer","title":"The Application layer","text":"<p>The Application layer combines the top three layers of the OSI model and its responsible for providing network services and applications to end-users.</p> <p>Although we can say that the OSI Presentation layer is part of the TCP/IP Application layer, no application requires any particular form of presentation as seen by the OSI model. Applications in TCP/IP already use standardized formats that everyone understands.\u00a0</p> <p>Furthermore, Session Layer's responsibilities are also handled by applications themselves - every application has to be able to initiate, control and disconnect from a remote system. There is no clearly defined way to do this and each TCP/IP application uses its own methods.</p> <p>All applications can talk to the network, so long they are part of the network. They also need to be part of the network to function: Web browsers, e-mail clients, multiplayer games etc.</p> <p>Just like in the OSI model, the Application Layer will produce a stream of data which will be handed off to the layer below it.</p>"},{"location":"internet-models.html#the-transport-layer","title":"The Transport Layer","text":"<p>The Transport Layer is equivalent to the OSI Transport layer. It\u2019s responsible for providing reliable end-to-end communication between applications running on different hosts. </p> <p>Much like it's OSI equivalent, Transport Layer will produce segments from the data that the Application Layer provided. It doesn't care how data is delivered because at some point of the data transfer, the destination device will have to know how to handle the data which Application Layer produced.</p> <p>Transport Layer includes two protocols - Transmission Control Protocol (TCP) and User Datagram Protocol (UDP).\u00a0</p> <ul> <li> <p>TCP is a connection-oriented protocol that provides reliable, ordered and error checked delivery of data between applications. As a consequence of adding all of those mechanisms, the data transmission will be reliable but slow.</p> </li> <li> <p>UDP is a connectionless communication that provides an unreliable, unordered and unchecked delivery of data. The trade-off is that the data transmission is much faster because it doesn't have to append extra bits to the segment. It\u2019s used with software like VoIP or video streaming.</p> </li> </ul> <p>TCP segments include fields:</p> <ul> <li>Destination port</li> <li>Source port</li> <li>Sequence number</li> <li>Checksum</li> <li>Flags</li> <li>Acknowledgement</li> <li>Data</li> </ul> <p>UDP on the other hand also gets the data from the Application layer and adds port and length numbers, as well as a checksum to create a container called a UDP datagram. UDP doesn\u2019t care if the receiving computer gets all its data, which is why UDP datagram lacks most of the fields found in TCP segments.</p> <p>In summary, data arrives from the Application layer which is then broken up into fragments, given destination, source and sequence numbers and then shipped to the Internetworking Layer to be wrapped into an IP packet.\u00a0</p>"},{"location":"internet-models.html#the-internetworking-layer","title":"The Internetworking Layer","text":"<p>The Internetworking layer is equivalent to OSI Network Layer and is responsible for handling logical addressing and routing (forwarding). </p> <p>The main protocol used on this layer Internet Protocol which provides a unique IP address to each device on the network. Any device or protocol that deals with pure IP packets sits on the Internetworking Layer. </p> <p>The Internet layer doesn\u2019t care what type of data the IP packet carries, nor does it care whether the data gets there in good order or not. That is handled by the Transport layer.</p> <p>Internetworking layer will take the segment provided by the Transport Layer and will create a packet.</p>"},{"location":"internet-models.html#network-access-layer","title":"Network Access Layer","text":"<p>Network Access Layer groups up the last two layers of the OSI model - Data-Link and Physical. The keyword in this layer is access - this layer deals with any physical (hardware) part of the network.</p>"},{"location":"magento.html","title":"Magento","text":""},{"location":"magento.html#redis","title":"Redis","text":""},{"location":"magento.html#elasticsearch","title":"ElasticSearch","text":""},{"location":"ping-traceroute-netstat.html","title":"Basic tools for computer network analysis","text":""},{"location":"ping-traceroute-netstat.html#ping","title":"ping","text":""},{"location":"ping-traceroute-netstat.html#traceroute-tracepath","title":"traceroute &amp; tracepath","text":""},{"location":"ping-traceroute-netstat.html#netstat","title":"netstat","text":""},{"location":"ssl.html","title":"SSL","text":""},{"location":"ssl.html#ssl","title":"SSL","text":"<p>SSL, or Secure Sockets Layer, is an encryption-based Internet security protocol. SSL encrypts data that is transmitted across the web. SSL is the predecessor to the modern TLS (Transport Layer Security) encryption used today (but people still refer to it as SSL).</p> <p>Anyone who tries to intercept this data will only see a garbled mix of characters that is nearly impossible to decrypt.</p> <p>SSL initiates an authentication process called a handshake between two communicating devices to ensure that both devices are really who they claim to be. SSL also digitally signs data in order to provide data integrity, verifying that the data is not tampered with before reaching its intended recipient.</p> <ul> <li>Secure Socket Layer</li> <li>SSL encrypts data that is transmitted across the web</li> <li>It initiates an auth process called a handshake between the two communicating devices to make sure that both are what they claim to be</li> <li>It\u2019s now TLS, but still called SSL</li> </ul> <p>https://www.cloudflare.com/learning/ssl/what-is-ssl/</p>"},{"location":"wordpress.html","title":"WP-CLI","text":""}]}